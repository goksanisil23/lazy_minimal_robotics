#include "KalmanTuner.h"
#include "KalmanErrorTerm.h"

template <typename T>
KalmanTuner<T>::KalmanTuner(const Eigen::VectorXd &x0)
{
    x_hat_ = x0;

    static const double dt{0.05};
    stateTransMtx_       = Eigen::MatrixXd::Identity(stateSize_, stateSize_);
    stateTransMtx_(0, 2) = dt;
    stateTransMtx_(1, 3) = dt;

    measMtx_       = Eigen::MatrixXd::Zero(measSize_, stateSize_);
    measMtx_(0, 0) = 1;
    measMtx_(1, 1) = 1;
    measMtx_(2, 4) = 1;
    measMtx_(3, 5) = 1;

    // Diagonals will be populated by tuning vars
    // processNoiseMtx_ = Eigen::MatrixXd::Zero(stateSize_, stateSize_);
    processNoiseMtx_ = Eigen::Matrix<T, stateSize_, stateSize_>();
    measNoiseMtx_    = Eigen::MatrixXd::Identity(measSize_, measSize_) * 1e-6;

    stateErrorCovMtx_ = Eigen::MatrixXd::Identity(measSize_, stateSize_) * 1.0;
}

template <typename T>
Eigen::MatrixXd KalmanTuner<T>::Predict()
{
    x_hat_            = stateTransMtx_ * x_hat_;
    stateErrorCovMtx_ = stateTransMtx_ * stateErrorCovMtx_ * stateTransMtx_.transpose() + processNoiseMtx_;
    return x_hat_;
}

template <typename T>
Eigen::MatrixXd KalmanTuner<T>::Correct(const Eigen::VectorXd &meas)
{
    static const Eigen::MatrixXd I = Eigen::MatrixXd::Identity(stateSize_);

    Eigen::MatrixXd K = stateErrorCovMtx_ * measMtx_.transpose() *
                        (measMtx_ * stateErrorCovMtx_ * measMtx_.transpose() + measNoiseMtx_).inverse();

    x_hat_            = x_hat_ + K * (meas - measMtx_ * x_hat_);
    stateErrorCovMtx_ = (I - K * measMtx_) * stateErrorCovMtx_;
    return x_hat_;
}

template <typename T>
void KalmanTuner<T>::Tune(const std::vector<cv::Rect> &gtBboxes)
{
    ceres::Problem       optProblem;
    ceres::LossFunction *lossFunc{nullptr};

    // Optimization parameters (Process noise & Measurement noise)
    std::vector<double> filterNoiseParams(10, 0.5);

    for (size_t i = 1; i < (gtBboxes.size() * 10); i++)
    {
        const cv::Rect2d      gtBbox(gtBboxes.at(i));
        const Eigen::VectorXd gtBboxVec(GetVecFromBbox(gtBbox));

        ceres::CostFunction *costFunc;
        // This runs Kalman predict step
        costFunc = KalmanErrorTerm::Create(gtBboxVec, shared_from_this());
        optProblem.AddResidualBlock(costFunc, lossFunc, filterNoiseParams.data());

        // Run measurement update every 10th frame
        if (i % 10 == 0)
        {
            this->Correct(gtBboxVec);
        }
    }

    ceres::Solver::Options solverOpts;
    solverOpts.linear_solver_type           = ceres::DENSE_QR;
    solverOpts.minimizer_progress_to_stdout = true;
    solverOpts.max_num_iterations           = 100;
    ceres::Solver::Summary solverSummary;

    ceres::Solve(solverOpts, &optProblem, &solverSummary);
    std::cout << solverSummary.FullReport() << "\n";
    std::cout << "Final Noise params:\n";
    std::for_each(filterNoiseParams.begin(), filterNoiseParams.end(), [](double param) { std::cout << param << " "; });
}

// returns c_x,c_y,v_x,v_y,w,h
template <typename T>
Eigen::VectorXd KalmanTuner<T>::GetStateFromBbox(const cv::Rect2d &bbox)
{
    Eigen::VectorXd state{Eigen::VectorXd::Zero(stateSize_)};
    state(0) = bbox.tl().x + bbox.width / 2.0;
    state(1) = bbox.tl().y + bbox.height / 2.0;
    state(4) = bbox.width;
    state(5) = bbox.height;

    return state;
}

// returns center_x, center_y, width, height
template <typename T>
Eigen::VectorXd KalmanTuner<T>::GetVecFromBbox(const cv::Rect2d &bbox) const
{
    Eigen::VectorXd meas{Eigen::VectorXd::Zero(measSize_)};
    meas(0) = bbox.tl().x + bbox.width / 2.0;
    meas(1) = bbox.tl().y + bbox.height / 2.0;
    meas(2) = bbox.width;
    meas(3) = bbox.height;

    return meas;
}
